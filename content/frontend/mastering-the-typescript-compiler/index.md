---
title: "Mastering the TypeScript Compiler"
date: 2021-07-05T08:24:46+01:00
draft: false
subtitle: "tsc or not tsc?"
banner: https://www.plantcode.blog/me/banner.jpg
categories: frontend
tags:
  - TypeScript
  - Compiler
---

The way TypeScript works is unusual compared to JavaScript and other popular languages.

Before we get a sense of how the TypeScript compiler is different, let's start broad and consider what compilers actually do.

Programs are files that contain a bunch of text. That text is parsed by a special program called a _compiler_, which transforms it into an [abstract syntax tree (AST)](https://www.twilio.com/blog/abstract-syntax-trees), a data structure that aims to convert raw data into a graphical format.

A compiler itself is also a program. The complier takes an input (such as the source code in the program that you, the programmer, has written) and produces something with it which can be made executable. What this means in practice is that the compiler takes something that's human-readable, analyses it and creates in-memory objects that can be manipulated programatically.

The details aren't relevant here, but [astexplorer](https://astexplorer.net/) is a great tool to see how syntax trees are created from source code.

The compiler then converts that AST to a lower-level representation called bytecode. You can feed that bytecode into another program called a _runtime_ to evaluate it and get a result. So when you run a program, what you're actually doing is telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code.

To summarise, the steps are:

- Program is parsed into an AST
- AST is compiled into bytecode
- Bytecode is evaluated by the runtime

Where TypeScript is special is that instead of compiling straight to bytecode, TypeScript compiles to JavaScript code!

The compile process between TypeScript and JavaScript is as follows:

**TypeScript ----> TypeScript AST ----> AST checked by typechecker ----> TypeScript AST ----> JavaScript**

**JavaScript ----> AST ----> Bytecode ----> Runtime**

After TypeScript generates an AST for your program but before it emits code, the TypeScript compiler makes your code safer by ‚ú®typechecking‚ú® your code.

**Typechecker**: A special program that verifies that your code is typesafe.


**Type system**: A set of rules that a typechecker uses to assign types to your program.

Type annotations take the `value: type` model.

Explicit Types:

{{< highlight typescript "linenos=tables,linenostart=1" >}}
let a: number = 1;
// a is a number
let b: string = "hello";
// b is a string
let c: boolean[] = [true, false];
// c is an array of booleans
{{< / highlight >}}

Type Inference:

{{< highlight typescript "linenos=tables,linenostart=1" >}}
let a = 1;
// a is a number
let b = "hello";
// b is a string
let c = [true, false];
// c is an array of booleans
{{< / highlight >}}

If you leave off the annotations, TypeScript is pretty good at inferring types for you. It's generally good practice to keep explicitly typed code at a minimum [according to most style guides](https://google.github.io/styleguide/tsguide.html#type-and-non-nullability-assertions). The below table is taken from Boris Cherney's excellent and highly recommended book on TypeScript (see references below).

| Type system feature                | JavaScript          | TypeScript               |
| ---------------------------------- | ------------------- | ------------------------ |
| How are types bound?               | Dynamically         | Statically               |
| Are types automatically converted? | Yes                 | No (mostly)              |
| When are types checked?            | At runtime          | At compile time          |
| When are errors surfaced?          | At runtime (mostly) | At compile time (mostly) |

TypeScript is [gradually typed](https://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/) because it uses a type system where you can explicity annotate your types, or you can let TypeScript infer most of them for you. You should aim for 100% type coverage because TypeScript works best when it knows the types of everything in your program at compile time, but it doesn't have to know every type in order to compile your program.

When `tsc` compiles your code from TypeScript to JavaScript, it won't look at your types. Your program's types do not affect your program's generated output and are only used for typechecking against TypeScript's _type system_.

üß† Protip: If you must convert types, do it explicity so type inference doesn't do anything you don't want.

## Handling errors between JavaScript and TypeScript

In JavaScript, errors surface only once you run the code because JavaScript does its implicit type conversions at _runtime_.

TypeScript on the other hand throws both syntax-related errors and type-related errors at compile time. In practice, that means those kinds of errors will show up in your code editor, right as you type. This decreases the feedback loop between mistakes and fixes.

## Get good at the tsc CLI üòé

First initialise a new npm project (follow the prompts)

`npm init`

Install TSC, TSLint, and type declarations for NodeJS

`npm install --save-dev typescript tslint @types/node`

In your terminal window:

{{< highlight typescript "linenos=tables,linenostart=1" >}}
tsc --init
// Initialises a TypeScript project
// and generates a tsconfig.json
// file in your root folder
{{< / highlight >}}

[tsconfigdemystified](https://generator.tsconfigdemystified.com/) is an excellent resource interactively outlines what you're missing different values for your tsconfig.json file do.

## Configure your linter

- Download the [ESlint extension for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint).
- TSLint was [deprecated in 2019](https://github.com/palantir/tslint/issues/4534) to support the migration to ESLint as the standard linter for both TypeScript & JavaScript.
- Follow all required steps in [this guide](https://github.com/typescript-eslint/typescript-eslint/blob/master/docs/getting-started/linting/README.md).

{{< highlight typescript "linenos=tables,linenostart=1" >}}
//.eslintrc.js

module.exports = {
root: true,
parser: '@typescript-eslint/parser',
plugins: [
'@typescript-eslint',
],
extends: [
'eslint:recommended',
'plugin:@typescript-eslint/recommended',
],
};
{{< / highlight >}}

Include Prettier (you may need to [install another config](https://github.com/typescript-eslint/typescript-eslint/blob/master/docs/getting-started/linting/README.md#usage-with-prettier)):

{{< highlight typescript "linenos=tables, hl_lines=12,linenostart=1" >}}
//.eslintrc.js

module.exports = {
root: true,
parser: '@typescript-eslint/parser',
plugins: [
'@typescript-eslint',
],
extends: [
'eslint:recommended',
'plugin:@typescript-eslint/recommended',
"prettier",
],
};
{{< / highlight >}}

Enable `node` support for ESLint. By [specifying your environment](https://eslint.org/docs/user-guide/configuring/language-options#using-configuration-files).

{{< highlight typescript "linenos=tables, hl_lines=12-14,linenostart=1" >}}
module.exports = {
root: true,
parser: '@typescript-eslint/parser',
plugins: [
'@typescript-eslint',
],
extends: [
'eslint:recommended',
'plugin:@typescript-eslint/recommended',
"prettier",
],
env: {
node: true,
},
};
{{< / highlight >}}

Expect to see the following dev dependencies installed in your `package.json` file.

{{< highlight typescript "linenos=tables, hl_lines=12-14,linenostart=1" >}}
//package.json

"devDependencies": {
"@types/node": "^15.6.1",
"@typescript-eslint/eslint-plugin": "^4.25.0",
"@typescript-eslint/parser": "^4.25.0",
"eslint": "^7.27.0",
"eslint-config-prettier": "^8.3.0",
"tslint": "^6.1.3",
"typescript": "^4.3.2"
}
{{< / highlight >}}

If you're getting this error: `‚ÄúESLint is disabled since its execution has not been approved or denied yet‚Äù` then you probably do not have the extension enabled. This can easily be configured at the bottom right corner of VSC.

{{< figure src="eslint-enable.png" caption="Enable the ESLint extension" >}}

## Using ts-node

`ts-node` allows you to compile and run your TypeScript with a single command.

run:

`npm install -D ts-node`

to install the package locally in your project.

If required, you can fetch the types associated with the project by running:

`npm install -D tslib @types/node`

You may then run:

`npm i -D nodemon`

[nodemon](https://github.com/remy/nodemon) allows you to watch for any changes in your node.js application and automatically restart your server. This is crucial for streamlining TypeScript workflow.

You can then set up the following npm scripts in your package.json folder:

{{< highlight typescript "linenos=tables, hl_lines=12-14,linenostart=1" >}}
//package.json

"scripts": {
"start": "node dist/index.js",
"dev": "nodemon src/index.ts",
"build": "tsc -p .",
"test": "echo \"Error: no test specified\" && exit 1"
}
{{< / highlight >}}

Any changes you make to your TypeScript file can be seen in the terminal when you run `npm run dev`.

If you would like to render the JavaScript file, simply run `npm run build` to allow TypeScript to compile, and then `npm run start` to see the rendered JavaScript in your terminal.

### References

https://medium.com/@dinis.cruz/ast-abstract-syntax-tree-538aa146c53b

[_Programming TypeScript_](https://www.oreilly.com/library/view/programming-typescript/9781492037644/) by Boris Cherney
