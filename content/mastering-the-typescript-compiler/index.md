---
title: "Mastering the TypeScript Compiler"
date: 2021-05-27T08:24:46+01:00
draft: false
subtitle: "tsc or not tsc?"
categories: -frontend
tags:
  - typescript
  - compilers
---

The way TypeScript works is unusual compared to JavaScript and other popular languages.

Before we get a sense of how the TypeScript compiler is different, let's start broad and consider what compilers actually do.

Programs are files that contain a bunch of text written by you, the programmer. That text is parsed by a special program called a _compiler_, which transforms it into an [abstract syntax tree (AST)](https://www.twilio.com/blog/abstract-syntax-trees), a data structure that ignores things like whitespace and comments and aims to convert raw data into a graphical format. This creates in-memory objects that can be manipulated programatically. The details aren't relevant here, but [astexplorer](https://astexplorer.net/) is a great tool to see how syntax trees are created from JavaScript.

The compiler then converts that AST to a lower-level representation called bytecode. You can feed that bytecode into another program called a _runtime_ to evaluate it and get a result. So when you run a program, what you're actually doing is telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code. The details vary, but for most languages this is an accurate high-level view.

To summarise, the steps are:

- Program is parsed into an AST
- AST is compiled into bytecode
- Bytecode is evaluated by the runtime

Where TypeScript is special is that instead of compiling straight to bytecode, TypeScript compiles to...JavaScript code!

Just before TypeScript does this, so after it generates an AST for your program but before it emits code, the TypeScript compiler makes your code safer by âœ¨typecheckingâœ¨ your code.

**Typechecker**: A special program that verifies that your code is typesafe.

When `tsc` compiles your code from TypeScript to JavaScript, it won't look at your types. Your program's types do not affect your program's generated output and are only used for typeschecking against TypeScript's _type system_.

**Type system**: A set of rules that a typechecker uses to assign types to your program.

Type annotations take the `value: type` model.

Explicit Types:

```typescript
let a: number = 1;
// a is a number
let b: string = "hello";
// b is a string
let c: boolean[] = [true, false];
// c is an array of booleans
```

Type Inference:

```typescript
let a = 1;
// a is a number
let b = "hello";
// b is a string
let c = [true, false];
// c is an array of booleans
```

If you leave off the annotations, TypeScript is pretty good at inferring types for you. It's generally good practice to keep explicitly typed code at a minimum [according to most style guides](https://google.github.io/styleguide/tsguide.html#type-and-non-nullability-assertions).

| Type system feature                | JavaScript  | TypeScript  |
| ---------------------------------- | ----------- | ----------- |
| How are types bound?               | Dynamically | Statically  |
| Are types automatically converted? | Yes         | No (mostly) |
|                                    |             |             |
|                                    |             |             |

TypeScript is [gradually typed](https://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/) because it uses a type system where you can explicity annotate your types, or you can let TypeScript infer most of them for you. You should aim for 100% type coverage because TypeScript works best when it knows the types of everything in your program at compile time, but it doesn't have to know every type in order to compile your program.

ğŸ§  Protip: If you must convert types, do it explicity so type inference doesn't do anything you don't want.

## Handling errors between JavaScript and TypeScript

In JavaScript, errors surface only once you run the code because JavaScript does its implicit type conversions at _runtime_.

TypeScript on the other hand throws both syntax-related errors and type-related errors at compile time. This decreases the feedback loop between mistakes and fixes.

## Get good at the tsc CLI ğŸ˜

In your terminal window:

```typescript
>> tsc --init
>>
>> // Initialises a TypeScript project
>> // and generates a tsconfig.json
>> // file in your root folder
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
```

## How are types bound?

Dynamic type binding means that JavaScript needs to actually run your
program to know the types of things in it. JavaScript doesnâ€™t know your
types before running your program.

TypeScript is a _gradually typed_ language.

That means that TypeScript works best when it knows the types of everything in your program at
compile time, but it doesnâ€™t have to know every type in order to compile
your program. Even in an untyped program TypeScript can infer some types
for you and catch some mistakes, but without knowing the types for
everything, it will let a lot of mistakes slip through to your users.

This gradual typing is really useful for migrating legacy codebases from
untyped JavaScript to typed TypeScript, but unless youâ€™re in the middle
of migrating your codebase, you should aim for 100% type coverage.

## Configure your linter

- Download the [ESlint extension for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint).
- TSLint was [deprecated in 2019](https://github.com/palantir/tslint/issues/4534) to support the migration to ESLint as the standard linter for both TypeScript & JavaScript.
- Follow all required steps in [this guide](https://github.com/typescript-eslint/typescript-eslint/blob/master/docs/getting-started/linting/README.md).

```typescript
>> //.eslintrc.js
>>
>> module.exports = {
>>   root: true,
>>   parser: '@typescript-eslint/parser',
>>   plugins: [
>>    '@typescript-eslint',
>>   ],
>>   extends: [
>>    'eslint:recommended',
>>    'plugin:@typescript-eslint/recommended',
>>   ],
>> };
>>
>>
>>
>>
>>
>>
```

Include Prettier:

```typescript
>> //.eslintrc.js
>>
>> module.exports = {
>>   root: true,
>>   parser: '@typescript-eslint/parser',
>>   plugins: [
>>    '@typescript-eslint',
>>   ],
>>   extends: [
>>    'eslint:recommended',
>>    'plugin:@typescript-eslint/recommended',
      "prettier",
>>   ],
>> };
>>
>>
>>
>>
>>
>>
```

- Enable `node` support for ESLint. By [specifying your environment](https://eslint.org/docs/user-guide/configuring/language-options#using-configuration-files).

```typescript
>> //.eslintrc.js
>>
>> module.exports = {
>>   root: true,
>>   parser: '@typescript-eslint/parser',
>>   plugins: [
>>    '@typescript-eslint',
>>   ],
>>   extends: [
>>    'eslint:recommended',
>>    'plugin:@typescript-eslint/recommended',
>>     "prettier",
>>   ],
>>   env: {
>>    node: true,
>>  },
>> };
>>
>>
>>
>>
>>
>>
```

- Expect to see the following dev dependencies installed in your `package.json` file.

```typescript
>> //.eslintrc.js
>>
>> module.exports = {
>>   root: true,
>>   parser: '@typescript-eslint/parser',
>>   plugins: [
>>    '@typescript-eslint',
>>   ],
>>   extends: [
>>    'eslint:recommended',
>>    'plugin:@typescript-eslint/recommended',
>>     "prettier",
>>   ],
>>   env: {
>>    node: true,
>>  },
>> };
>>
>>
>>
>>
>>
>>
```

- If you're getting this error: `â€œESLint is disabled since its execution has not been approved or denied yetâ€` then you probably do not have the extension enabled. This can easily be configured at the bottom right corner of VSC.

{{< figure src="eslint-enable.png" caption="Enable the ESLint extension" >}}

### References

https://medium.com/@dinis.cruz/ast-abstract-syntax-tree-538aa146c53b
