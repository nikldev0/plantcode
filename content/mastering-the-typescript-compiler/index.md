---
title: "Mastering the TypeScript Compiler"
date: 2021-05-27T08:24:46+01:00
draft: false
subtitle: "tsc or not tsc?"
categories: -frontend
tags:
  - typescript
  - compilers
---

The way TypeScript works is unusual compared to JavaScript and other popular languages.

Before we get a sense of how the TypeScript compiler is different, let's start broad and consider what compilers actually do.

Programs are files that contain a bunch of text written by you, the programmer. That text is parsed by a special program called a _compiler_, which transforms it into an [abstract syntax tree (AST)](https://www.twilio.com/blog/abstract-syntax-trees), a data structure that ignores things like whitespace, comments and tabs vs. spaces.

The compiler then converts that AST to a lower-level representation called bytecode. You can feed that bytecode into another program called a _runtime_ to evaluate it and get a result. So when you run a program, what you're actually doing is telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code. The details vary, but for most languages this is an accurate high-level view.

To summarise, the steps are :

**Program is parsed into an AST.**

**AST is compiled into bytecode.**

**Bytecode is evaluated by the runtime.**

Where TypeScript is special is that instead of compiling straight to bytecode, TypeScript compiles to...JavaScript code!

Just before TypeScript does this, so after it generates an AST for your program but before it emits code, the TypeScript compiler makes your code safer by ✨typechecking✨ your code.

Explicit Types:

```typescript
let a: number = 1;
let b: string = "hello";
let c: boolean[] = [true, false];
```

Type Inference:

```typescript
let a = 1;
let b = "hello";
let c = [true, false];
```

If you leave off the annotations, TypeScript is pretty good at inferring types for you. It's generally good practice to keep explicitly typed code at a minimum [according to most style guides](https://google.github.io/styleguide/tsguide.html#type-and-non-nullability-assertions).

| Type system feature  | JavaScript  | TypeScript |
| -------------------- | ----------- | ---------- |
| How are types bound? | Dynamically | Statically |
|                      |             |            |
|                      |             |            |
|                      |             |            |

In your terminal window:

```typescript
>> tsc --init
>>
>> // Generates a tsconfig.json file in your root folder
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
```

## How are types bound?

Dynamic type binding means that JavaScript needs to actually run your
program to know the types of things in it. JavaScript doesn’t know your
types before running your program.

TypeScript is a _gradually typed_ language.

That means that TypeScript works best when it knows the types of everything in your program at
compile time, but it doesn’t have to know every type in order to compile
your program. Even in an untyped program TypeScript can infer some types
for you and catch some mistakes, but without knowing the types for
everything, it will let a lot of mistakes slip through to your users.

This gradual typing is really useful for migrating legacy codebases from
untyped JavaScript to typed TypeScript, but unless you’re in the middle
of migrating your codebase, you should aim for 100% type coverage.
